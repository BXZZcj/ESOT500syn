import argparse
from pathlib import Path
import numpy as np
import cv2
from tqdm import tqdm

def visualize_event_stream(
    event_stream: np.ndarray,
    output_path: Path,
    height: int,
    width: int,
    fps: int,
    keep_polarity: bool,
    ceil: int,
    percentile: int
):
    """
    convert event stream data to a visualization video.

    Args:
        event_stream (np.ndarray): the structured event array loaded from the .npz file.
        output_path (Path): the path to the output video file.
        height (int): the height of the video frame.
        width (int): the width of the video frame.
        fps (int): the frame rate of the output video.
        keep_polarity (bool): whether to use color to distinguish positive and negative polarity.
        ceil (int): the fixed upper bound of the event count, used for normalization.
        percentile (int): the dynamic upper bound percentile of the event count, used for normalization.
    """
    # ensure the event stream is sorted by timestamp
    event_stream.sort(order='timestamp')
    
    min_ts = event_stream['timestamp'][0]
    max_ts = event_stream['timestamp'][-1]
    duration_us = max_ts - min_ts
    
    time_per_frame_us = 1e6 / fps
    num_frames = int(np.ceil(duration_us / time_per_frame_us))

    print(f"event stream total duration: {duration_us / 1e6:.2f} seconds.")
    print(f"will generate {num_frames} frames, {fps} FPS.")

    frames = []
    
    # use histogram2d to accelerate the generation of event frames
    print("generating event frames...")
    for i in tqdm(range(num_frames)):
        start_ts = min_ts + i * time_per_frame_us
        end_ts = start_ts + time_per_frame_us
        
        # use numpy's boolean indexing to efficiently select the events for the current frame
        frame_events = event_stream[(event_stream['timestamp'] >= start_ts) & (event_stream['timestamp'] < end_ts)]
        
        if keep_polarity:
            pos_events = frame_events[frame_events['polarity'] == 1]
            neg_events = frame_events[frame_events['polarity'] == 0]
            
            pos_frame, _, _ = np.histogram2d(pos_events['y'], pos_events['x'], bins=[height, width], range=[[0, height], [0, width]])
            neg_frame, _, _ = np.histogram2d(neg_events['y'], neg_events['x'], bins=[height, width], range=[[0, height], [0, width]])
            
            # positive polarity (ON) -> red, negative polarity (OFF) -> green
            frame = np.stack([pos_frame, neg_frame, np.zeros((height, width))], axis=-1)
        else:
            gray_frame, _, _ = np.histogram2d(frame_events['y'], frame_events['x'], bins=[height, width], range=[[0, height], [0, width]])
            frame = np.stack([gray_frame] * 3, axis=-1)
            
        frames.append(frame)

    frames = np.array(frames, dtype=np.float32)
    
    # normalize to get better visual effect
    print("normalizing frames...")
    non_zero_values = frames[frames > 0]
    if len(non_zero_values) > 0:
        # use ceil and percentile to determine the upper bound of normalization
        upper_bound = np.percentile(non_zero_values, percentile)
        norm_ceil = min(upper_bound, ceil)
        print(f"event count {percentile}% percentile value: {upper_bound:.2f}")
        print(f"used normalization upper bound (min(ceil, percentile)): {norm_ceil:.2f}")
        
        frames = np.clip(frames, 0, norm_ceil) / norm_ceil
    
    # write to video file
    fourcc = cv2.VideoWriter_fourcc(*'mp4v')
    video_writer = cv2.VideoWriter(str(output_path), fourcc, fps, (width, height))
    
    print(f"writing video file to: {output_path}")
    for frame in tqdm(frames):
        # convert to 8-bit integer
        img = (frame * 255).astype(np.uint8)
        # OpenCV uses BGR format, our frames are RGB (R=pos, G=neg, B=0)
        img_bgr = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)
        video_writer.write(img_bgr)
        
    video_writer.release()
    print("video writing completed!")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="create a visualization video from the .npz event stream file generated by v2ce.py.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    # core input/output parameters
    parser.add_argument("-i", "--input_file", type=str, help="the path to the .npz event stream file.")
    parser.add_argument("-o", "--output_file", type=str, default=None, help="the path to the output .mp4 video file. if not provided, will be automatically generated based on the input file name.")
    
    # video metadata (since .npz does not contain this information, user needs to provide)
    parser.add_argument("--height", type=int, required=True, help="**required** the height of the original video (e.g. 260).")
    parser.add_argument("--width", type=int, required=True, help="**required** the width of the original video (e.g. 346).")
    
    # visualization control parameters
    parser.add_argument("--fps", type=int, default=30, help="the frame rate of the output video.")
    parser.add_argument("--no_polarity", action="store_false", dest="keep_polarity", help="if set, will generate a grayscale video, instead of using color to distinguish polarity.")
    parser.add_argument("--ceil", type=int, default=10, help="the fixed upper bound of the event count in the visualization video.")
    parser.add_argument("-u", "--upper_bound_percentile", type=int, default=98, help="the dynamic upper bound percentile of the event count in the visualization video.")

    args = parser.parse_args()

    input_path = Path(args.input_file)
    if not input_path.is_file():
        print(f"error: input file does not exist -> {input_path}")
        exit(1)

    if args.output_file:
        output_path = Path(args.output_file)
    else:
        # automatically generate output file name
        output_path = input_path.with_name(f"{input_path.stem}_visualization.mp4")
    
    # ensure the output directory exists
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    try:
        print(f"loading event stream: {input_path}")
        with np.load(input_path) as data:
            # the key saved by v2ce.py is 'event_stream'
            if 'event_stream' not in data:
                print(f"error: 'event_stream' key not found in the .npz file.")
                exit(1)
            event_stream = data['event_stream']
        print(f"loaded successfully, {len(event_stream)} events.")
        
        visualize_event_stream(
            event_stream=event_stream,
            output_path=output_path,
            height=args.height,
            width=args.width,
            fps=args.fps,
            keep_polarity=args.keep_polarity,
            ceil=args.ceil,
            percentile=args.upper_bound_percentile
        )

    except Exception as e:
        print(f"error: {e}")